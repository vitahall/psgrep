#!/usr/bin/perl
# psgrep - greps process list

use warnings;
use strict;

use List::Util qw/max/;
use Data::Dumper;

use Getopt::Long qw/:config posix_default bundling no_ignore_case/;
use Pod::Usage;

my $LONG_FORMAT;
my $PID_ONLY;
my $help_level;
GetOptions(
    'long|f'    => \$LONG_FORMAT,
    'pid|p'     => \$PID_ONLY,
    'help|h'    => sub { $help_level = 1 },
    'man',      => sub { $help_level = 2 },
) or pod2usage(-verbose => 1);

pod2usage(-verbose => $help_level) if $help_level;

my @LONG_KEYWORDS = qw/uid pid ppid stat tty time command/;

=head1 NAME

scriptname - does something

=head1 SYNOPSIS

scriptname [--help|--man]

=head1 OPTIONS

=over 4

=item B<--help>

Prints a usage and options summary.

=item B<--man>

Displays the manual.

=back

=head1 DESCRIPTION

Right now, I think it just prints "Hello, world!".

=head1 DIAGNOSTICS

None.

=head1 BUGS

None, obviously.

=head1 ENVIRONMENT

=over 4

=item TMPDIR

All your data goes here.

=back

=head1 AUTHOR

Copyright 2012 Aaron Hall.

=cut

my $COMPARISON_OPS = qr/(?:[<>=]|\s(?:eq|ne)\s|[!=]~)/;

# get our operations
sub main {
    my @ops = get_ops_from_args(@ARGV);
    die "error: no arguments\n" unless @ops;

    my @keywords = map { $_->[0] } @ops;

    # -f given
    if ($LONG_FORMAT) {
        @keywords = (@keywords, @LONG_KEYWORDS);
    }

    # command & pid will always be there; put them up front for uniq
    unshift @keywords, 'command', 'pid';
    @keywords = uniq(@keywords);

    # now move 'command' to the end (yeah, I'm being fancy for no reason)
    push @keywords, shift @keywords;
    
    # now call ps
    my @processes = grep_ps(\@keywords, \@ops);

    my $lengths_ref = pop(@processes);   # pop the lengths off the end
    my $headers_ref = shift(@processes); # and the headers off the front

    # exit if there are no actual processes
    exit 0 unless scalar(@processes);

    # build a format string
    if ($PID_ONLY) {
        @keywords = ('pid');
        undef $headers_ref;
    }
    my $format_str = build_format_str(\@keywords, $lengths_ref);

    foreach my $proc_ref ($headers_ref, @processes) {
        print_formatted($format_str, \@keywords, $proc_ref);
    }
}


sub get_ops_from_args {
    my @args = @_;

    if (@args == 1) {
        # one arg, could be a keyword-op-value or just a regex match
        # try to DWIM
        my $arg = $args[0];
        if ($arg =~ m[^/(.+)/([ixgc]*)]) {
            # if it looks like a /regex/, treat it as one
            my ($re, $flags) = ($1, $2);
            return([ command => "=~ m/$re/$flags" ]);
        }
        elsif ($arg !~ $COMPARISON_OPS) {
            return([ command => "=~ m/$arg/" ]);
        }
        else {
            # continue into the multi-arg parser below
        }
    }

    my @ops;
    foreach my $arg (@args) {
        # here, we look for keyword+everything-else
        if ($arg =~ /^(\w+)(\W.+)$/) {
            my ($keyword, $rest) = ($1, $2);
            # throw out bare =
            if ($rest =~ /^\s*=\s*\d/) {
                die "error: = should be == in '${keyword}${rest}'\n";
            }
            # DWIM: autoquote bareword in eq or ne
            $rest =~ s/^(\s*(?:eq|ne)\s+)(\S+)$/$1"$2"/;
            push @ops, [ $keyword, $rest ];
        }
        else {
            die "can't understand $arg\n";
        }
    }

    return(@ops);
}


sub run_ps {
    my @keywords = @_;

    my $kw_str = join(',', @keywords);

    open my $ps_fh, '-|', "ps", "ax", "-o${kw_str}" or die "can't run ps, exiting\n";
    my @lines = (<$ps_fh>);
    close $ps_fh;
    return @lines;
}

sub grep_ps {
    my @keywords = @{shift(@_)};
    my @ops      = @{shift(@_)};

    unshift @keywords, 'ppid';  # needed in select_ps_lines
    my @ps_lines = run_ps(@keywords);
    return select_ps_lines(\@keywords, \@ops, @ps_lines);
}

# takes a list of lines from ps output and returns an array of hashrefs
sub select_ps_lines {
    my @keywords = @{shift(@_)};
    my @ops      = @{shift(@_)};
    my @ps_lines = @_;

    # build the perl to do the evaluations
    my $perl_eval;
    OP: foreach my $op_ref (@ops) {
        my ($keyword, $op) = @{$op_ref};
        $perl_eval .= ' && ' if $perl_eval;
        $perl_eval .= "(\$fields{" . $keyword . "} $op)";
    }

    #read the first line
    my $num_keywords = scalar @keywords;
    my %lengths;
    my @selected;
    my $line_num = 0;
    PROCESS: foreach my $line (@ps_lines) {
        chomp $line;
        $line_num++;

        my %fields;
        @fields{@keywords} = split(' ', $line, $num_keywords);

        if ($line_num == 1) {
            # create a faux process record with the headers and lengths
            my %headers;
            @headers{@keywords} = map { uc $_ } @keywords;
            push @selected, \%headers;

            tally_lengths(\%lengths, \%headers);
            next PROCESS;
        }

        # ignore ourselves
        next PROCESS if $fields{'pid'} == $$ or $fields{'ppid'} == $$;

        # run the eval
        my $ok;
        {
            no strict;
            no warnings qw/uninitialized once/;
            $ok = eval "$perl_eval";
        }

        if ($ok) {
            # we've got a match, record it
            tally_lengths(\%lengths, \%fields);
            push @selected, \%fields;
        }
        else {
            if ($@) {
                die "psgrep failed (line $line_num): $@";
            }
        }
    }

    push @selected, \%lengths; # being lazy
    return(@selected);
}


sub tally_lengths {
    my $lengths_ref = shift;
    my $fields_ref  = shift;

    no warnings 'uninitialized';
    foreach my $field (keys %{$fields_ref}) {
        $lengths_ref->{$field} = max(
            $lengths_ref->{$field},
            length($fields_ref->{$field}),
        );
    }
}


sub build_format_str {
    my @keywords = @{shift(@_)};
    my %lengths  = %{shift(@_)};

    my $str;
    # build a string based on the lengths of all but the last field
    for (my $i = 0; $i <= ($#keywords - 1); $i++) {
        my $key = $keywords[$i];
        my $len = $lengths{$key};
        $str .= "%-${len}s ";
    }

    # no length specifier on the last field
    $str .= "%s\n";
    return $str;
}


sub print_formatted {
    my $format_str = shift;
    my $keys_ref   = shift;
    my $proc_ref   = shift;

    return unless $proc_ref;

    my @keywords = @{$keys_ref};
    my %process  = %{$proc_ref};

    printf $format_str, @process{@keywords};
}


# uniq - taken from List::MoreUtils to eliminate dependency on
# that module. Written by Eric J. Roode, Tassilo von Parseval,
# and Adam Kennedy.
sub uniq (@) {
    my %seen = ();
    grep { not $seen{$_}++ } @_;
}


main();
