#!/usr/bin/perl
# psgrep - greps process list

use warnings;
use strict;

use List::Util qw/max/;
use Data::Dumper;

use Getopt::Long qw/:config posix_default bundling no_ignore_case/;
use Pod::Usage;

my $LONG_FORMAT;
my $PID_ONLY;
my @ADD_KEYWORDS;
my $help_level;
GetOptions(
    'long|f'      => \$LONG_FORMAT,
    'pid|p'       => \$PID_ONLY,
    'output|o=s'  => \@ADD_KEYWORDS,
    'help|h'      => sub { $help_level = 1 },
    'man',        => sub { $help_level = 2 },
) or pod2usage(-verbose => 1);

pod2usage(-verbose => $help_level) if $help_level;

my @LONG_KEYWORDS = qw/uid pid ppid stat tty time command/;

my $COMPARISON_OPS = qr/(?:[<>=]|\s(?:eq|ne)\s|[!=]~)/;

# get our operations
sub main {
    my @ops = get_ops_from_args(@ARGV);
    pod2usage("error: no arguments") unless @ops;

    my @keywords = map { $_->[0] } @ops;

    push(@keywords, @LONG_KEYWORDS) if $LONG_FORMAT;
    @keywords = fixup_keywords(@keywords, @ADD_KEYWORDS);

    # now call ps
    my @processes = grep_ps(\@keywords, \@ops);

    my $lengths_ref = pop(@processes);   # pop the lengths off the end
    my $headers_ref = shift(@processes); # and the headers off the front

    # exit if there are no actual processes
    exit 0 unless scalar(@processes);

    # build a format string
    if ($PID_ONLY) {
        @keywords = ('pid');
        undef $headers_ref;
    }
    my $format_str = build_format_str(\@keywords, $lengths_ref);

    foreach my $proc_ref ($headers_ref, @processes) {
        print_formatted($format_str, \@keywords, $proc_ref);
    }
}


sub fixup_keywords {
    my(@input) = @_;
    my @return;
    my %seen;

    @input = split(/,/, join(',', @input));
    foreach my $key (@input) {
        next if $seen{$key};
        next if $key =~ /^(?:pid|command)$/;

        push @return, $key;
        $seen{$key} = 1;
    }

    @return = ('pid', @return, 'command');
    return @return;
}


sub get_ops_from_args {
    my @args = @_;

    if (@args == 1) {
        # one arg, could be a keyword-op-value or just a regex match
        # try to DWIM
        my $arg = $args[0];
        if ($arg =~ m[^/(.+)/([ixauld]*)]) {
            # if it looks like a /regex/, treat it as one
            my ($re, $flags) = ($1, $2);
            return([ command => "=~ m/$re/$flags" ]);
        }
        elsif ($arg !~ $COMPARISON_OPS) {
            return([ command => "=~ m/$arg/" ]);
        }
        else {
            # continue into the multi-arg parser below
        }
    }

    my @ops;
    foreach my $arg (@args) {
        # here, we look for keyword+everything-else
        if ($arg =~ /^(\w+)(\W.+)$/) {
            my ($keyword, $rest) = ($1, $2);
            # throw out bare =
            if ($rest =~ /^\s*=\s*\d/) {
                die "psgrep: single = should be == in '${keyword}${rest}'\n";
            }
            # DWIM: autoquote bareword in eq or ne
            $rest =~ s/^(\s*(?:eq|ne)\s+)(\S+)$/$1"$2"/;
            push @ops, [ $keyword, $rest ];
        }
        else {
            die "psgrep: can't understand $arg\n";
        }
    }

    return(@ops);
}


sub run_ps {
    my @keywords = @_;

    my $kw_str = join(',', @keywords);

    open my $ps_fh, '-|', "ps", "ax", "-o${kw_str}"
      or die "psgrep: can't run ps, exiting\n";
    my @lines = (<$ps_fh>);
    close $ps_fh;
    return @lines;
}

sub grep_ps {
    my @keywords = @{shift(@_)};
    my @ops      = @{shift(@_)};

    unshift @keywords, 'ppid';  # needed in select_ps_lines
    my @ps_lines = run_ps(@keywords);
    return select_ps_lines(\@keywords, \@ops, @ps_lines);
}

# takes a list of lines from ps output and returns an array of hashrefs
sub select_ps_lines {
    my @keywords = @{shift(@_)};
    my @ops      = @{shift(@_)};
    my @ps_lines = @_;

    # build the perl to do the evaluations
    my $perl_eval;
    OP: foreach my $op_ref (@ops) {
        my ($keyword, $op) = @{$op_ref};
        $perl_eval .= ' && ' if $perl_eval;
        $perl_eval .= "(\$fields{" . $keyword . "} $op)";
    }

    #read the first line
    my $num_keywords = scalar @keywords;
    my %lengths;
    my @selected;
    my $line_num = 0;
    PROCESS: foreach my $line (@ps_lines) {
        chomp $line;
        $line_num++;

        my %fields;
        @fields{@keywords} = split(' ', $line, $num_keywords);

        if ($line_num == 1) {
            # create a faux process record with the headers and lengths
            my %headers;
            @headers{@keywords} = map { uc $_ } @keywords;
            push @selected, \%headers;

            tally_lengths(\%lengths, \%headers);
            next PROCESS;
        }

        # ignore ourselves
        next PROCESS if $fields{'pid'} == $$ or $fields{'ppid'} == $$;

        # run the eval
        my $ok;
        {
            no strict;
            no warnings qw/uninitialized once/;
            $ok = eval "$perl_eval";
        }

        if ($ok) {
            # we've got a match, record it
            tally_lengths(\%lengths, \%fields);
            push @selected, \%fields;
        }
        else {
            if ($@) {
                die "psgrep: perl error (line $line_num): $@";
            }
        }
    }

    push @selected, \%lengths; # being lazy
    return(@selected);
}


sub tally_lengths {
    my $lengths_ref = shift;
    my $fields_ref  = shift;

    no warnings 'uninitialized';
    foreach my $field (keys %{$fields_ref}) {
        $lengths_ref->{$field} = max(
            $lengths_ref->{$field},
            length($fields_ref->{$field}),
        );
    }
}


sub build_format_str {
    my @keywords = @{shift(@_)};
    my %lengths  = %{shift(@_)};

    my $str;
    # build a string based on the lengths of all but the last field
    for (my $i = 0; $i <= ($#keywords - 1); $i++) {
        my $key = $keywords[$i];
        my $len = $lengths{$key};
        $str .= "%-${len}s ";
    }

    # no length specifier on the last field
    $str .= "%s\n";
    return $str;
}


sub print_formatted {
    my $format_str = shift;
    my $keys_ref   = shift;
    my $proc_ref   = shift;

    return unless $proc_ref;

    my @keywords = @{$keys_ref};
    my %process  = %{$proc_ref};

    printf $format_str, @process{@keywords};
}


# uniq - taken from List::MoreUtils to eliminate dependency on
# that module. Written by Eric J. Roode, Tassilo von Parseval,
# and Adam Kennedy.
sub uniq (@) {
    my %seen = ();
    grep { not $seen{$_}++ } @_;
}


main();

=head1 NAME

psgrep - search for processes matching given criteria

=head1 SYNOPSIS

psgrep [--help|--man] [-pf] [-o KEYWORDS] /REGEX/

psgrep [--help|--man] [-pf] [-o KEYWORDS] '<KEYWORD op OPERAND>' ...

=head1 OPTIONS

=over 4

=item B<-f>, B<--long>

Print these fields for every process:
C<< uid pid ppid stat tty time command >>.
Any fields specified in comparison operations or with B<--output> will
also be printed. If both this option and B<--pid> are specified, B<--pid>
wins.

=item B<-o>, B<--output> KEYWORDS

In addition to any keywords specified in operations (and those that
B<--long> adds if you use it), also print the fields associated with the
keywords given. The option can be specified multiple times, and also
accepts multiple comma-delimited keywords, after the B<-o> option in
I<ps>. If you also give B<--pid>, that wins.

=item B<-p>, B<--pid>

Print only the PIDs of the matching processes. Giving B<-p> overrides
any use of B<-f> or B<-o>.

=item B<-h>, B<--help>

Prints a usage and options summary.

=item B<--man>

Displays the manual.

=back

=head1 DESCRIPTION

B<psgrep> prints information about processes matching given criteria.
You can make comparisons against any keyword that your I<ps> command's
B<-o> option supports. B<psgrep> assumes by default that you're running
it interactively and want to see the process information that you're
comparing against. So comparing against a field automatically causes
that field to be printed.

In the first form, you simply give a regular expression to match against
the command and arguments. In the second, you give one or more comparison
operations to specify which processes you want.

If you give the B<-p> option, B<psgrep> will instead print only the PID
of matching processes without a header, no matter what other options you
give, or what kind of comparison operations you specify.

=head1 OPERATIONS

An operation is a comparison against some piece of data (a "field")
about a process. You specify the field by its name (or "keyword"). The
available fields and their interpretations vary from system to system.
For a full list of fields, see the documentation for B<-o> in ps(1).

Operations are of the form:

    KEYWORD op OPERAND

For example:

    user eq 'root'
    pid > 1
    command =~ /http/

The field name (or "keyword") must be a single word (in perl, it must
look like an identifier). Only alphanumeric keywords are accepted.
The entire operation must be in a single shell argument. Quote as
necessary.

You can specify multiple operations: 

    psgrep uid==0 'command =~ /sh/'

All operations must return true for a process to match (i.e. they're
&&'d together).

=head2 Operators

The available operators are:

    ==, >, >=, <, <=    numeric comparison
    eq, ne              string comparison
    =~, !~              regex pattern match

The operations are performed as in Perl; B<psgrep> builds perl code that
actually performs the operations. 

=head2 Keywords

A few common ones are:

    command     command and arguments
    pid         process's group ID
    pcpu        percentage CPU usage
    pid         process ID
    ppid        parent process ID
    rss         resident set size
    stat        symbolic process state
    tty         full name of control terminal
    uid         process's user ID
    user        user name (from uid)
    vsz         virtual memory size of the process

Again, both the available fields and their interpretations vary
from system to system. See ps(1) for a complete list for your system.

=head2 Single Regex Argument

For convenience, B<psgrep> treats a single argument specially. A single
argument need not have a comparison operator. If not, it is treated as a
Perl regex match against the I<command> field. This makes the simple
case simple:

    psgrep http      # matches "httpd" or "wget http://example.com/"
    psgrep '[Mm]ail' # "Mail", "mail", "mailx", "sendmail" ...

You can surround the regex with slashes; this lets you use the C<i>, C<x>,
C<a>, C<u>, C<d>, and C<l> regex modifiers (when available on your version
of Perl). The following three commands are equivalent:

    psgrep /Perl/i
    psgrep 'command =~ m[Perl]i'
    psgrep '[Pp][Ee][Rr][Ll]'

Note that you'll typically have to quote the use of brackets from your
shell, since they're used in shell globbing syntax. Strictly speaking,
you don't have to quote constructs that don't interfere
with shell syntax, but it's often a good idea.

=head1 DIAGNOSTICS

=over 4

=item "can't understand <ARG>"

What you gave doesn't look like an operation to B<psgrep>. Operations
should look like C<KEYWORD op OPERAND>. In particular, I<KEYWORD> must
be an alphanumeric string, and I<operator> must be one of the operators
given above.

You might have used the one-argument regex syntax but added a second
argument. You can't say this:

    psgrep httpd uid=501

Once you add a second operation, you have to say this:

    psgrep 'command =~ httpd' uid=501

=item "single = should be == in '<ARG>'"

You must say:

    psgrep 'uid == 0'   # not psgrep 'uid = 0'

=item "can't run ps, exiting"

For some reason, B<psgrep> couldn't find or execute your B<ps>
program. Maybe the PATH isn't set up right?

=item "<ARG>: keyword not found"

C<ps -o> on your system doesn't know what <ARG> means. See ps(1) for
a list of keywords that will work for you.

=item "perl error (line <NUM>): <some perl error>"

Something you passed made Perl's compiler die. This can happen if your
operand isn't something perl recognizes. (The operand is not parsed by
B<psgrep> and is passed directly to perl.) Most warnings are promoted to
fatal errors with C<< use warnings FATAL >>.

=back

=head1 BUGS

B<psgrep> assumes that no output field but C<command> will contain
spaces. If this isn't true (and on some systems it isn't), B<psgrep>
will mis-parse the output from I<ps>. The C<args> keyword is an
alias of C<command> on many systems, and will cause this behavior.
This may be fixed in the future. For now, don't do that.

You should still be able to use the one-arg regex operation even though
you've also got other operations.

=head1 SEE ALSO

ps(1), perlop(1), perlre(1)

=head1 AUTHOR

Copyright 2012 Aaron Hall. <ahall@vitaphone.net>

This B<psgrep> script is made available under the terms of the Artistic
License 2.0, available at L<http://www.perlfoundation.org/artistic_license_2_0>.

=head1 HISTORY

Inspired by the "psgrep" program given as an example at the end of
Chapter 1 of Perl Cookbook, 1st. Ed., by Tom Christiansen and Nat
Torkington (O'Reilly and Associates, 1998). It takes a somewhat different
approach and shares no code with that "psgrep", though.

=cut
